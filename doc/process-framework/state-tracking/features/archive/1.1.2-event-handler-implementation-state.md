---
id: PF-FEA-010
type: Process Framework
category: Feature Implementation State
version: 1.0
created: 2026-02-18
updated: 2026-02-18
status: Retrospective Analysis
feature_id: 1.1.2
implementation_mode: Retrospective Analysis
feature_name: event-handler
---

# event-handler - Implementation State

> **ðŸ“– Usage guide**: [Feature Implementation State Tracking Guide (PF-GDE-043)](../../guides/guides/feature-implementation-state-tracking-guide.md)
>
> **Retrospective Analysis mode** (onboarding tasks [PF-TSK-064](../../tasks/00-onboarding/codebase-feature-discovery.md), [PF-TSK-065](../../tasks/00-onboarding/codebase-feature-analysis.md), [PF-TSK-066](../../tasks/00-onboarding/retrospective-documentation-creation.md)):
> - Section 3 tracks analysis progress rather than planned tasks
> - Section 5 (Code Inventory) is the primary deliverable â€” every file must be assigned
> - Section 7 documents decisions discovered in code, not planned decisions
> - All content is descriptive ("what is") rather than prescriptive ("what should be")

---

## 1. Feature Overview

### Feature Description

The Event Handler (`LinkMaintenanceHandler`) is the central coordinator for real-time file system event processing. It inherits from watchdog's `FileSystemEventHandler` and overrides `on_moved()`, `on_deleted()`, and `on_created()` to implement LinkWatcher's core response logic. `on_modified()` is intentionally not overridden â€” LinkWatcher tracks path changes, not content changes.

For **file move events**, the handler (1) queries the link database for all references to the old path using multiple path format strategies (exact, relative, backslash, filename-only), (2) calls the updater to rewrite those references in their containing files, and (3) rescans all affected files to rebuild the database. For **directory moves**, it walks the new directory, calculates oldâ†’new path mappings for each file, and processes each file's references individually.

For **delete events**, the handler uses a delayed processing strategy: it buffers delete events in `pending_deletes` for 2 seconds, during which it waits to see if a corresponding create event arrives. This solves the problem that some tools (git operations, certain file managers) report moves as delete+create pairs rather than native move events. For **create events**, the handler checks whether the creation matches a pending delete (indicating a cross-tool move) and routes accordingly.

### Business Value

- **User Need**: File moves should automatically update all cross-file references without developer intervention
- **Business Goal**: Eliminate manual link maintenance after any file reorganization operation
- **Success Metrics**: References updated correctly for 100% of file moves and renames; zero broken links after move operations

### Scope

**In Scope**:

- File move handling (native watchdog move events)
- Directory move handling (updates all files within moved directory)
- Delete event processing with delayed move detection (2-second buffer)
- Create event processing with move detection
- `on_modified` is intentionally absent (file content changes don't break links)

**Out of Scope**:

- File content parsing (delegated to `parser.py` / feature 2.1.1)
- Link database reads/writes (delegated to `database.py` / feature 0.1.3)
- File modification/writing (delegated to `updater.py` / feature 2.2.1)

---

## 2. Current State Summary

**Last Updated**: 2026-02-18
**Current Status**: MAINTAINED
**Current Task**: PF-TSK-065 (Codebase Feature Analysis â€” retrospective)
**Completion**: 100% complete

### What's Working

- [âœ“] File move handling with multi-format path lookup and deduplication
- [âœ“] Directory move handling with file-by-file processing
- [âœ“] Delayed move detection (2-second buffer for delete+create moves)
- [âœ“] File creation scanning (new files added to database)
- [âœ“] Statistics tracking (files_moved, files_deleted, files_created, links_updated, errors)
- [âœ“] `@with_context` logging decorator for structured event logging

### What's In Progress

_Nothing in progress â€” feature is stable._

### What's Blocked

_No blockers._

---

## 3. Implementation Progress

### Task Sequence

> **Retrospective Analysis Mode**: This section tracks analysis progress rather than implementation tasks.

- [âœ“] **PF-TSK-064**: Codebase Feature Discovery & Code Assignment
  - **Completed**: 2026-02-18
  - **Key Outputs**: Feature state file (PF-FEA-010) created; code inventory populated in Section 5
  - **Status**: COMPLETE âœ…

- [âœ“] **PF-TSK-065**: Codebase Feature Analysis â† CURRENT SESSION
  - **Completed**: 2026-02-18
  - **Key Outputs**: Sections 1, 2, 3, 6, 7 populated with retrospective analysis content
  - **Status**: COMPLETE âœ…

- [âœ“] **PF-TSK-066**: Retrospective Documentation Creation
  - **Tier**: Tier 2 â€” FDD + TDD created
  - **Completed**: 2026-02-19
  - **Key Outputs**: FDD PD-FDD-024, TDD PD-TDD-023
  - **Status**: COMPLETE âœ…

---

## 4. Documentation Inventory

### Design Documentation

| Document | Type | Status | Location | Last Updated |
| -------- | ---- | ------ | -------- | ------------ |
| [FDD PD-FDD-024: Event Handler](../../../../../product-docs/functional-design/fdds/fdd-1-1-2-event-handler.md) | FDD | Created | doc/product-docs/functional-design/fdds/fdd-1-1-2-event-handler.md | 2026-02-19 |
| [TDD PD-TDD-023: Event Handler](../../../../../product-docs/technical/architecture/design-docs/tdd/tdd-1-1-2-event-handler-t2.md) | TDD (Tier 2) | Created | doc/product-docs/technical/architecture/design-docs/tdd/tdd-1-1-2-event-handler-t2.md | 2026-02-19 |

### User Documentation

| Document   | Type         | Status   | Location | Last Updated |
| ---------- | ------------ | -------- | -------- | ------------ |
| N/A | - | - | - | - |

### Developer Documentation

| Document   | Type          | Status   | Location | Last Updated |
| ---------- | ------------- | -------- | -------- | ------------ |
| N/A | - | - | - | - |

### Existing Project Documentation

> Records pre-existing project documentation identified during onboarding audit (PF-TSK-064 step 4). Content relevance is confirmed during analysis (PF-TSK-065). Confirmed entries guide documentation creation (PF-TSK-066) to extract rather than re-derive.

| Document | Type | Relevant Content | Confirmed | Notes |
| -------- | ---- | ---------------- | --------- | ----- |
| [HOW_IT_WORKS.md](../../../../../HOW_IT_WORKS.md) | Architecture Overview | Move/delete event detection, event processing pipeline | Confirmed | Covers event handler architecture and event types |

### Quick Links

- **Main Design**: [Link]
- **Implementation Tasks**: [Link]
- **Related Features**: [Link]

---

## 5. Code Inventory

### Files Created by This Feature

| File Path | Purpose | Key Components | Status | Created |
| --------- | ------- | -------------- | ------ | ------- |
| [linkwatcher/handler.py](../../../../linkwatcher/handler.py) | File system event handler | `LinkWatcherHandler`, `on_moved()`, `on_created()`, `on_deleted()`, `on_modified()` | COMPLETE | Pre-framework |
| [debug/debug_directory_handler.py](../../../../debug/debug_directory_handler.py) | Debug script for handler | Handler debugging and investigation | COMPLETE | Dev tool |
| [debug/debug_nested_directory.py](../../../../debug/debug_nested_directory.py) | Debug for nested directory handling | Nested directory event debugging | COMPLETE | Dev tool |
| [debug/investigate_directory_test.py](../../../../debug/investigate_directory_test.py) | Investigation for directory move behavior | Directory move analysis | COMPLETE | Dev tool |
| [debug/test_directory_move.py](../../../../debug/test_directory_move.py) | Test for directory move handling | Directory move event testing | COMPLETE | Dev tool |
| [debug/test_file_movement_demo.py](../../../../debug/test_file_movement_demo.py) | Demo for file movement event flow | Event flow demonstration | COMPLETE | Dev tool |

### Files Modified by This Feature

_No files modified â€” handler is a standalone component._

### Test Files

| Test File | Type | Coverage Areas | Status | Created |
| --------- | ---- | -------------- | ------ | ------- |
| [tests/integration/test_file_movement.py](../../../../tests/integration/test_file_movement.py) | Integration | Move/rename/delete event handling | COMPLETE | Pre-framework |
| [tests/integration/test_complex_scenarios.py](../../../../tests/integration/test_complex_scenarios.py) | Integration | Complex event sequences | COMPLETE | Pre-framework |
| [tests/integration/test_sequential_moves.py](../../../../tests/integration/test_sequential_moves.py) | Integration | Sequential file moves | COMPLETE | Pre-framework |
| [tests/integration/test_windows_platform.py](../../../../tests/integration/test_windows_platform.py) | Integration | Windows-specific event handling | COMPLETE | Pre-framework |

### Database/Schema Changes

_No database schema changes._

---

## 6. Dependencies

### Feature Dependencies

**This Feature Depends On**:

- **[0.1.2 Data Models](./0.1.2-data-models-implementation-state.md)** (MAINTAINED)
  - Why: Creates `FileOperation` instances to represent detected file events; reads `LinkReference` instances from the database
  - Impact if unavailable: Cannot represent or process file events

- **[0.1.3 In-Memory Database](./0.1.3-in-memory-database-implementation-state.md)** (MAINTAINED)
  - Why: Queries `link_db.get_references_to_file()` to find all files that reference a moved file
  - Impact if unavailable: Cannot determine which files need link updates

- **[0.1.5 Path Utilities](./0.1.5-path-utilities-implementation-state.md)** (MAINTAINED)
  - Why: Uses `should_monitor_file()` and `should_ignore_directory()` to filter which events to process
  - Impact if unavailable: All file events would be processed indiscriminately

- **[2.1.1 Parser Framework](./2.1.1-parser-framework-implementation-state.md)** (MAINTAINED)
  - Why: After a file move, calls `parser.parse_file()` to rescan affected files and rebuild their link entries
  - Impact if unavailable: Database would have stale entries after moves

- **[2.2.1 Link Updater](./2.2.1-link-updater-implementation-state.md)** (MAINTAINED)
  - Why: Calls `updater.update_references()` to write updated link paths to affected files
  - Impact if unavailable: Link references could not be rewritten

- **[3.1.1 Logging Framework](./3.1.1-logging-framework-implementation-state.md)** (MAINTAINED)
  - Why: Uses `get_logger()` for structured event processing logs
  - Impact if unavailable: No logging output; functional degradation, not failure

**Other Features Depend On This**:

- **[0.1.1 Core Architecture](./0.1.1-core-architecture-implementation-state.md)** (MAINTAINED)
  - Why: `LinkWatcherService` instantiates `LinkMaintenanceHandler` and passes it to the watchdog Observer
  - Note: Handler is the primary integration point between watchdog events and business logic

- **[1.1.1 Watchdog Integration](./1.1.1-watchdog-integration-implementation-state.md)** (MAINTAINED)
  - Why: `observer.schedule(handler, ...)` requires a handler instance; watchdog dispatches events to it
  - Note: Handler and Observer are paired; neither functions without the other

### System Dependencies

**Required Services**:

- `watchdog.events.FileSystemEventHandler`: Base class providing event dispatch interface

**Required Packages**:

| Package   | Version | Purpose                                              | Added         |
| --------- | ------- | ---------------------------------------------------- | ------------- |
| watchdog  | â‰¥2.0    | `FileSystemEventHandler` base class, event types     | Pre-framework |
| threading | stdlib  | `threading.Timer`, `threading.Lock` for move detection | Pre-framework |

### Code Dependencies

**Existing Code This Feature Imports**:

| Component                | Used For                      | Methods/APIs Used                                          | Notes                              |
| ------------------------ | ----------------------------- | ---------------------------------------------------------- | ---------------------------------- |
| [linkwatcher/handler.py](../../../../linkwatcher/handler.py) | All event handler logic       | `on_moved`, `on_deleted`, `on_created`, move detection     | Primary file for this feature      |
| [linkwatcher/database.py](../../../../linkwatcher/database.py) | Link lookups                 | `get_references_to_file()`, `remove_links_for_file()`      | Database queried per event         |
| [linkwatcher/updater.py](../../../../linkwatcher/updater.py)  | Writing link updates         | `update_references()`                                      | Final step of event processing     |
| [linkwatcher/parser.py](../../../../linkwatcher/parser.py)   | Post-move rescan             | `parse_file()`                                             | Rebuilds database after move       |
| [linkwatcher/utils.py](../../../../linkwatcher/utils.py)    | File/dir filtering           | `should_monitor_file()`, `should_ignore_directory()`       | All events pass through this check |

> **Note**: Also uses `watchdog` (>=2.0, external) for `FileSystemEventHandler` base class, `threading` (stdlib) for move detection timer/lock.

**Reverse Code Dependencies** (files that import this feature):

| Component | How They Use This Feature | Methods/APIs Used | Notes |
| --------- | ------------------------- | ----------------- | ----- |
| [linkwatcher/service.py](../../../../linkwatcher/service.py) | Instantiates handler and registers with Observer | `LinkMaintenanceHandler()`, passed to `observer.schedule()` | Service owns the handler instance |
| [tests/unit/test_handler.py](../../../../tests/unit/test_handler.py) | Tests all event handler methods | `on_moved`, `on_deleted`, `on_created`, move detection | Unit test coverage |
| [tests/integration/test_service_integration.py](../../../../tests/integration/test_service_integration.py) | Tests handler in full service context | `LinkMaintenanceHandler` via service | Integration test coverage |

---

## 7. Design Decisions

### Decision 1: Two-Second Delayed Move Detection via `pending_deletes`

**Date**: Pre-framework (discovered in code)
**Context**: watchdog does not always fire `on_moved` for all move operations (especially cross-filesystem moves or certain OS-level events). Delete + create pairs must be correlated to detect moves.

**Options Considered**:

1. Treat every delete as a true delete: Simple but loses link history for many move operations
2. Buffer deletes and correlate with creates: Two-second window to match delete+create pairs by filename and file size
3. Use OS-native rename tracking: Platform-specific, complex, not portable

**Decision Made**: `pending_deletes` dict + `threading.Timer(2.0, ...)` to buffer deletes and check for matching creates

**Rationale**: Buffering deletes in a dict keyed by filename and checking on creates allows reliable move detection even when watchdog fires `on_deleted` + `on_created` rather than `on_moved`. The 2-second window balances detection reliability against latency.

**Implications**:

- True deletions trigger link cleanup with a 2-second delay, not immediately
- Moves detected via this path are treated identically to direct `on_moved` events
- Thread safety requires `move_detection_lock` around `pending_deletes` access
- The timer callback and `on_created` handler can race â€” lock required

**Validation**: Confirmed â€” `pending_deletes` dict and `threading.Timer(2.0, self._execute_delete, [file_path])` in `_handle_file_deleted()`.

---

### Decision 2: No `on_modified` Override

**Date**: Pre-framework (discovered in code)
**Context**: `FileSystemEventHandler` provides `on_modified` for content change events. The decision was whether to monitor content changes.

**Options Considered**:

1. Override `on_modified` to detect when links change in file content: Would catch manual link edits but triggers on every keystroke â€” very noisy
2. Not overriding `on_modified`: Only structural events (moves, deletes, creates) trigger link maintenance â€” consistent with the system's purpose

**Decision Made**: `on_modified` is intentionally NOT overridden

**Rationale**: LinkWatcher's purpose is to maintain links when files move, not when file content changes. Monitoring content changes would create excessive noise (every save triggers an event) and false positives. Users editing link text manually is out of scope.

**Implications**:

- Manual link edits by users are not detected or corrected automatically
- System focuses exclusively on structural changes (file moves/renames/deletes)
- Performance is significantly better â€” no per-keystroke processing

**Validation**: Confirmed â€” `LinkMaintenanceHandler` only defines `on_moved`, `on_deleted`, `on_created`.

---

### Decision 3: Deduplication via 4-Tuple Key

**Date**: Pre-framework (discovered in code)
**Context**: When a file moves, multiple parsers might detect the same link reference, or the handler might process the same link update twice in edge cases.

**Options Considered**:

1. No deduplication: Risk of updating the same file location twice, corrupting content
2. Deduplication by file path only: Too coarse â€” a file might have multiple links to the same target
3. Deduplication by (file_path, line_number, column_start, link_target): Uniquely identifies each link occurrence

**Decision Made**: `(file_path, line_number, column_start, link_target)` 4-tuple as deduplication key in a `seen` set

**Rationale**: A link is uniquely identified by its source file, location within the file, and target. This 4-tuple is the minimal key that prevents double-updates while allowing multiple distinct links in the same file.

**Implications**:

- Each link occurrence updated exactly once per event, even if detected by multiple code paths
- Memory overhead per event is minimal (small set of tuples, discarded after event processing)

**Validation**: Confirmed in `_handle_file_moved()` â€” `seen` set initialized per event with 4-tuple keys.

---

### Implementation Patterns Used

**Move Detection Pattern**:

- Pattern: Buffer + timer + correlation (pending_deletes dict)
- Why: watchdog doesn't always fire `on_moved`; delete+create pairs must be matched
- Where: `_handle_file_deleted()`, `_detect_potential_move()`, `_handle_file_created()`

**Thread Safety Pattern**:

- Pattern: Single `threading.Lock` guarding shared mutable state (`pending_deletes`)
- Why: watchdog dispatches events from a background thread; timer callbacks run in separate threads
- Where: `move_detection_lock` used in all `pending_deletes` access

---

### Implementation Patterns Used

**State Management Pattern**:

- Pattern: [e.g., Riverpod AsyncNotifier]
- Why: [Reason]
- Where: [Components]

**Error Handling Pattern**:

- Pattern: [e.g., Result<T, E> wrapper]
- Why: [Reason]
- Where: [Layers]

**Data Flow Pattern**:

- Pattern: [e.g., Repository â†’ Provider â†’ UI]
- Why: [Reason]
- Where: [Components]

---

## 8. Issues & Resolutions Log

### Issue 1: Stale line numbers cause link updates to fail after file editing (PD-BUG-005)

**Status**: REPORTED
**Severity**: MEDIUM
**Reported**: 2026-02-19
**Resolved**: â€”
**Task**: Discovered during PF-TSK-065 (Codebase Feature Analysis)

**Problem**: When a user edits a file and adds or removes lines, LinkWatcher does not rescan the file because `on_modified` is intentionally not overridden (Decision 2). The in-memory database retains stale `line_number` values from the last scan. When a referenced file is subsequently moved, the updater (`updater.py:119-122`) uses these stale line numbers to locate the lines for replacement. If lines were added above a link, the updater looks at the wrong line, finds no matching link text via `_replace_in_line()`, and silently makes no change. The link reference becomes broken.

**Impact**:

- What: Link updates silently fail â€” references are not updated after file moves
- Scope: Any file that was edited (lines added/removed) since its last scan and that contains links to files that are subsequently moved
- Users: Any user who edits files and then moves referenced files before a rescan occurs

**Investigation**:

- Analysis of Decision 3 (4-tuple deduplication) â†’ Deduplication itself works correctly even with stale line numbers (same stale values from same database entries, so duplicates still match)
- Analysis of `_update_file_references()` in `updater.py` â†’ Confirmed: the updater uses `ref.line_number - 1` as a direct line index (line 120), which points to the wrong line when content has shifted
- Analysis of `_replace_in_line()` â†’ Confirmed: the method does text matching before replacing, so it won't corrupt data â€” it just silently fails to update

**Root Cause**: The combination of (1) intentionally not overriding `on_modified` (Decision 2) and (2) the updater relying on exact line numbers from the database for positional updates creates a silent failure when files are edited between scans.

**Resolution**: Not yet resolved. Potential approaches:
1. **Content-based search**: Instead of relying on stored line numbers, search the entire file for the link target text when the line-number-based lookup fails to match
2. **Rescan on save**: Add a lightweight rescan triggered by file modification events (contradicts Decision 2 but could be made efficient)
3. **Full-file regex replacement**: Replace the line-by-line approach with a full-file regex that doesn't depend on line numbers

**Prevention**: Any fix should ensure the updater does not silently skip updates. At minimum, a fallback search mechanism should be added.

**Notes for Next Session**: Bug tracked as PD-BUG-005 in [Bug Tracking](../../state-tracking/permanent/bug-tracking.md). Needs triage (Bug Triage task PF-TSK-041) before fixing.

---

### Tech Debt and Known Limitations

| Item   | Type      | Reason   | Current Mitigation | Priority   | Estimated Effort | Future Resolution | Tracked In |
| ------ | --------- | -------- | ------------------ | ---------- | ---------------- | ----------------- | ---------- |
| [Item] | Tech Debt | [Reason] | [Mitigation]       | [Priority] | [Effort]         | [Plan]            | [Issue #]  |

**Type Legend**:

- **Tech Debt**: Shortcuts that should be refactored
- **Known Limitation**: Feature constraints or missing functionality
- **Architectural Constraint**: System-level limitations

---

## 9. Next Steps

**Last Updated**: YYYY-MM-DD HH:MM

### Immediate Next Actions

1. **[Action 1 - Most Important]**

   - **Why**: [Reason this is priority]
   - **How**: [Specific steps]
   - **Files**: [Which files]
   - **Estimate**: [Time/complexity]

2. **[Action 2]**

   - **Why**: [Reason]
   - **How**: [Steps]
   - **Dependencies**: [What must be done first]
   - **Estimate**: [Time/complexity]

3. **[Action 3]**
   - **Why**: [Reason]
   - **How**: [Steps]
   - **Estimate**: [Time/complexity]

### Upcoming Work (Next 1-2 Tasks)

- [ ] [Work item 1] - Expected: 2026-02-18
- [ ] [Work item 2] - Expected: 2026-02-18
- [ ] [Work item 3] - Expected: 2026-02-18

### Questions That Need Answers

1. [Question affecting next steps]
2. [Question needing clarification]

### Recommended Starting Points for Next Session

**If Continuing Current Task**:

- Start in: [Specific file/component]
- Context needed: [What to understand]
- Previous work: [What just completed]

**If Starting Next Task**:

- Prerequisites: [What to verify]
- Begin with: [Where to start]
- Reference: [What to read]

---

## 10. Quality Metrics

**Last Updated**: YYYY-MM-DD

### Code Quality

**Linting**:

- Total Issues: [Number]
- Critical: [Number]
- Warnings: [Number]
- Status: [CLEAN | NEEDS_ATTENTION]

**Code Review**:

- Status: [SELF_REVIEWED | PEER_REVIEWED | NOT_REVIEWED]
- Reviewer: [Name]
- Review Date: YYYY-MM-DD
- Issues Found: [Number and severity]

**Documentation Coverage**:

- Public APIs Documented: [X]%
- Complex Logic Explained: [YES | PARTIAL | NO]
- Code Comments Quality: [GOOD | ADEQUATE | NEEDS_IMPROVEMENT]

### Test Coverage

**Unit Tests**:

- Coverage: [X]%
- Tests Written: [Number]
- Tests Passing: [Number]
- Critical Paths Covered: [YES | PARTIAL | NO]

**Widget Tests**:

- Coverage: [X]%
- Tests Written: [Number]
- Tests Passing: [Number]
- Key UI Flows Covered: [YES | PARTIAL | NO]

**Integration Tests**:

- End-to-End Scenarios: [Number defined] / [Number implemented]
- Tests Passing: [Number]
- Critical User Journeys Covered: [YES | PARTIAL | NO]

### Performance Metrics

| Metric        | Target   | Current   | Status   | Notes   |
| ------------- | -------- | --------- | -------- | ------- |
| [Metric name] | [Target] | [Current] | [Status] | [Notes] |

### Standards Compliance

- [ ] Follows project coding standards
- [ ] Adheres to Flutter best practices
- [ ] Follows Riverpod patterns
- [ ] Security requirements met
- [ ] Accessibility requirements met

---

## 11. API Documentation Reference

### Public APIs Exposed by This Feature

| Component | Type   | Documentation Link | Status   | Notes   |
| --------- | ------ | ------------------ | -------- | ------- |
| [Name]    | [Type] | [Link]             | [STATUS] | [Notes] |

### Key Integration Points

**This Feature Exposes**:

- [API/capability 1]
- [API/capability 2]

**This Feature Requires**:

- [Dependency 1] (`method()`)
- [Dependency 2] (model/API)

**Events Emitted**:

- [Event 1], [Event 2], [Event 3]

**See Full API Documentation**: [Link to comprehensive docs]

---

## 12. Lessons Learned

**Last Updated**: YYYY-MM-DD

### What Went Well

#### Success 1: [Title]

**What Happened**: [Description]

**Why It Worked**: [Contributing factors]

**Application to Future Work**: [How to replicate]

**Process Framework Insight**: [Framework improvement insights]

---

### What Could Be Improved

#### Improvement Area 1: [Title]

**What Happened**: [Description]

**Impact**: [Effect on implementation]

**Root Cause**: [Why this happened]

**Suggested Improvement**: [Specific recommendation]

**Process Framework Action**: [Needed framework change]

---

### AI Collaboration Patterns

**Effective Patterns**:

- [Pattern 1]: [What worked well]
- [Pattern 2]: [Effective communication/workflow]

**Ineffective Patterns**:

- [Pattern 1]: [What didn't work] - [Why] - [Better approach]
- [Pattern 2]: [What didn't work] - [Why] - [Better approach]

### Tool and Technique Insights

**Helpful Tools/Approaches**:

- [Tool 1]: [How it helped] - [When to use]
- [Tool 2]: [How it helped] - [When to use]

**Limitations Discovered**:

- [Limitation 1]: [What didn't work] - [Workaround] - [Alternative]
- [Limitation 2]: [What didn't work] - [Workaround] - [Alternative]

### Recommendations for Similar Features

1. [Recommendation 1 with rationale]
2. [Recommendation 2 with rationale]
3. [Recommendation 3 with rationale]

### Open Questions for Framework Evolution

1. [Question about process or template]
2. [Question about task structure or guidance]
