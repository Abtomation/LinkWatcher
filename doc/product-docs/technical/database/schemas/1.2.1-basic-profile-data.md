---
id: PD-SCH-010
type: Process Framework
category: Schema Design
version: 1.1
created: 2025-10-12
updated: 2025-01-27
feature_id: 1.2.1
schema_type: modification
feature_name: basic-profile-data
change_notes: "v1.1 - Updated to align with IMP-097/IMP-098: Refocused Integration Impact and Testing Strategy sections to use cross-reference format"
---

# Basic Profile Data Schema Design

## Overview

**Feature**: Basic Profile Data
**Schema Type**: Modification
**Description**: Schema design for Basic Profile Data feature

## Context & Requirements

### Feature Requirements

<!-- Link to or summarize the feature requirements that drive this schema design -->

**Related Documents**:

- [FDD-1.2.1: Basic Profile Data](/doc/product-docs/functional-design/fdds/fdd-1-2-1-basic-profile-data.md)
- [TDD-1.2.1: Basic Profile Data (Tier 3)](/doc/product-docs/technical/architecture/design-docs/tdd/tdd/tdd-1.2.1-basic-profile-data-t1.md)

**Core Requirements**:

- **User Profile Management**: Store and manage comprehensive user profile information
  - Mandatory fields: username (unique, immutable), email (unique, validated), first_name, last_name
  - Optional fields: profile_picture, gender, phone_number, birthday, address (street_address, city, postal_code, country)
  - Privacy controls: first_name and last_name visibility toggle (default: hidden)
- **Payment Methods Management**: Securely store multiple payment methods per user

  - Support multiple payment methods with PCI DSS compliance
  - Tokenization workflow (never store full card numbers)
  - Default payment method selection
  - Store card metadata: last 4 digits, brand, expiry date
  - Encrypted billing address storage

- **Business Rules**:
  - Username: 3-30 characters, alphanumeric + underscores, unique, immutable after creation
  - Email: Valid format, unique across system
  - Age validation: Users must be 16+ years (GDPR/FADP compliance)
  - Card validation: Luhn algorithm for card number validation
  - Payment tokens: Encrypted at rest using AES-256

### Current Schema State

<!-- Document the current database schema that will be affected -->

- **Existing Tables**:

  - `users` table with basic fields:
    - `id` (UUID, primary key)
    - `email` (TEXT, unique)
    - `display_name` (TEXT)
    - `avatar_url` (TEXT)
    - `bio` (TEXT)
    - `preferences` (JSONB)
    - `level` (INTEGER)
    - `points` (INTEGER)
    - `is_provider` (BOOLEAN)
    - `created_at`, `updated_at` (TIMESTAMP)
    - Note: No existing address fields

- **Current Relationships**:

  - Users table is referenced by multiple tables (bookings, reviews, etc.)
  - No existing payment methods storage

- **Known Constraints**:
  - Email must remain unique
  - New address fields (street_address, city, postal_code, country) will be added as optional fields
  - Cannot break existing foreign key relationships
  - Must maintain backward compatibility during migration

### Data Flow Requirements

<!-- Describe how data flows through the system -->

- **Input Sources**:

  - User registration/onboarding flow (username, email, name)
  - Profile settings screen (all profile fields)
  - Payment method addition flow (card details â†’ tokenization â†’ storage)
  - Image upload service (profile pictures)

- **Processing Requirements**:

  - Username validation: Check uniqueness, format compliance
  - Email validation: Format check, uniqueness verification
  - Age calculation: Derive from birthday, enforce 16+ requirement
  - Payment tokenization: External payment gateway API call before storage
  - Image processing: Resize, optimize, store URL reference
  - Encryption: AES-256 for payment tokens and billing addresses

- **Output Destinations**:
  - Profile display screens (with privacy controls applied)
  - Payment selection UI (masked card details)
  - Friend lists (username, optional name based on privacy settings)
  - Booking flows (default payment method selection)
  - Analytics service (anonymized profile data)

## Data Model Design

### Entity Definitions

<!-- Define all entities (tables) that will be created or modified -->

#### users (Modified)

- **Purpose**: Extended user profile table to store comprehensive user information including personal details and privacy settings
- **Primary Key**: `id` (UUID)
- **Modification Type**: Add new columns to existing table
- **Fields** (New/Modified only):
  | Field Name | Data Type | Constraints | Description |
  |------------|-----------|-------------|-------------|
  | username | VARCHAR(30) | NOT NULL, UNIQUE, CHECK (username ~ '^[a-zA-Z0-9_]{3,30}$') | Unique username, 3-30 chars, alphanumeric + underscores, immutable after creation |
  | first_name | VARCHAR(100) | NOT NULL | User's first name |
  | last_name | VARCHAR(100) | NOT NULL | User's last name |
  | show_name_to_friends | BOOLEAN | NOT NULL, DEFAULT FALSE | Privacy control: whether to show real name to friends (default: hidden) |
  | profile_image_url | TEXT | NULL | URL to user's profile picture (stored in cloud storage) |
  | gender | VARCHAR(50) | NULL | User's gender (optional, free text for inclusivity) |
  | phone_number | VARCHAR(20) | NULL, CHECK (phone_number ~ '^\+?[0-9\s\-\(\)]+$') | User's phone number with international format support |
  | birthday | DATE | NULL, CHECK (birthday <= CURRENT_DATE - INTERVAL '16 years') | User's date of birth, must be 16+ years old |
  | street_address | VARCHAR(255) | NULL | Street address (e.g., "123 Main St") |
  | city | VARCHAR(100) | NULL | City name |
  | postal_code | VARCHAR(20) | NULL | Postal/ZIP code |
  | country | VARCHAR(100) | NULL | Country name |

**Notes**:

- Existing fields (`id`, `email`, `display_name`, `avatar_url`, `bio`, `preferences`, `level`, `points`, `is_provider`, `created_at`, `updated_at`) remain unchanged
- `username` must be set during registration and cannot be changed afterward (enforced at application level)
- `email` constraint remains unique (existing constraint)
- Age validation (16+) enforced via CHECK constraint on `birthday` field

#### payment_methods (New)

- **Purpose**: Securely store tokenized payment method information for users with PCI DSS compliance
- **Primary Key**: `id` (UUID)
- **Fields**:
  | Field Name | Data Type | Constraints | Description |
  |------------|-----------|-------------|-------------|
  | id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique identifier for payment method |
  | user_id | UUID | NOT NULL, REFERENCES users(id) ON DELETE CASCADE | Foreign key to users table |
  | payment_type | VARCHAR(20) | NOT NULL, CHECK (payment_type IN ('credit_card', 'debit_card', 'paypal', 'bank_transfer')) | Type of payment method |
  | payment_token | TEXT | NOT NULL | Encrypted payment token from payment gateway (AES-256 encrypted) |
  | card_last_4 | VARCHAR(4) | NULL, CHECK (card_last_4 ~ '^[0-9]{4}$') | Last 4 digits of card (for display purposes only) |
  | card_brand | VARCHAR(20) | NULL | Card brand (Visa, Mastercard, Amex, etc.) |
  | expiry_month | INTEGER | NULL, CHECK (expiry_month BETWEEN 1 AND 12) | Card expiry month (1-12) |
  | expiry_year | INTEGER | NULL, CHECK (expiry_year >= EXTRACT(YEAR FROM CURRENT_DATE)) | Card expiry year (must be current year or future) |
  | billing_street_address | TEXT | NULL | Encrypted billing street address (AES-256 encrypted) |
  | billing_city | TEXT | NULL | Encrypted billing city (AES-256 encrypted) |
  | billing_postal_code | TEXT | NULL | Encrypted billing postal code (AES-256 encrypted) |
  | billing_country | TEXT | NULL | Encrypted billing country (AES-256 encrypted) |
  | is_default | BOOLEAN | NOT NULL, DEFAULT FALSE | Whether this is the user's default payment method |
  | is_active | BOOLEAN | NOT NULL, DEFAULT TRUE | Whether this payment method is active (soft delete) |
  | created_at | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT CURRENT_TIMESTAMP | Timestamp when payment method was added |
  | updated_at | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT CURRENT_TIMESTAMP | Timestamp when payment method was last updated |

**Notes**:

- `payment_token` and all billing address fields (billing_street_address, billing_city, billing_postal_code, billing_country) are encrypted at rest using AES-256
- Never store full card numbers (PCI DSS compliance)
- Only one payment method per user can be marked as `is_default` (enforced via unique partial index)
- Soft delete via `is_active` flag to maintain transaction history
- Billing address fields use same structure as user profile address fields for consistency

### Relationships

<!-- Define relationships between entities -->

- **users â†’ payment_methods**: One-to-Many - A user can have multiple payment methods
  - Foreign Key: `payment_methods.user_id` REFERENCES `users.id` ON DELETE CASCADE
  - Cascade delete ensures payment methods are removed when user is deleted
  - Indexed on `user_id` for efficient lookup

### Constraints & Validation Rules

<!-- Define business rules and data constraints -->

#### Table-Level Constraints

**users table**:

- **username_format**: `CHECK (username ~ '^[a-zA-Z0-9_]{3,30}$')` - Ensures username is 3-30 characters, alphanumeric + underscores
- **username_unique**: `UNIQUE (username)` - Ensures username uniqueness across system
- **email_unique**: `UNIQUE (email)` - Existing constraint, ensures email uniqueness
- **age_requirement**: `CHECK (birthday <= CURRENT_DATE - INTERVAL '16 years')` - Enforces minimum age of 16 years
- **phone_format**: `CHECK (phone_number ~ '^\+?[0-9\s\-\(\)]+$')` - Validates phone number format

**payment_methods table**:

- **card_last_4_format**: `CHECK (card_last_4 ~ '^[0-9]{4}$')` - Ensures last 4 digits are numeric
- **expiry_month_range**: `CHECK (expiry_month BETWEEN 1 AND 12)` - Validates month range
- **expiry_year_future**: `CHECK (expiry_year >= EXTRACT(YEAR FROM CURRENT_DATE))` - Ensures expiry year is not in the past
- **payment_type_enum**: `CHECK (payment_type IN ('credit_card', 'debit_card', 'paypal', 'bank_transfer'))` - Validates payment type
- **one_default_per_user**: Unique partial index `CREATE UNIQUE INDEX idx_payment_methods_user_default ON payment_methods(user_id) WHERE is_default = TRUE AND is_active = TRUE` - Ensures only one active default payment method per user

#### Application-Level Validation Rules

**Username Validation**:

- Format: 3-30 characters, alphanumeric + underscores only
- Uniqueness: Case-insensitive check (implement via lowercase index)
- Immutability: Once set, username cannot be changed (enforced in application logic)

**Email Validation**:

- Format: RFC 5322 compliant email format
- Uniqueness: Case-insensitive check
- Verification: Email verification required before account activation

**Age Validation**:

- Minimum age: 16 years (GDPR/FADP compliance)
- Calculation: Based on birthday field
- Enforcement: Both database CHECK constraint and application-level validation

**Payment Card Validation**:

- Luhn algorithm: Validate card number before tokenization
- Expiry validation: Card must not be expired
- CVV validation: Required during tokenization (never stored)

**Privacy Controls**:

- `show_name_to_friends`: Default FALSE (names hidden by default)
- Application must respect this flag when displaying user information to other users

## Performance Considerations

### Indexing Strategy

<!-- Define indexes needed for optimal performance -->

**users table indexes**:

- **idx_users_username**: `CREATE UNIQUE INDEX idx_users_username ON users(LOWER(username))`
  - Purpose: Case-insensitive username uniqueness and fast lookup
  - Justification: Username is used for user search and profile access, target <50ms lookup time
- **idx_users_email**: `CREATE UNIQUE INDEX idx_users_email ON users(LOWER(email))` (Existing, may need modification)
  - Purpose: Case-insensitive email uniqueness and fast lookup
  - Justification: Email is used for login and user identification, target <50ms lookup time
- **idx_users_birthday**: `CREATE INDEX idx_users_birthday ON users(birthday) WHERE birthday IS NOT NULL`
  - Purpose: Age-based queries and analytics
  - Justification: Partial index for non-null birthdays, used for age verification and demographic analysis

**payment_methods table indexes**:

- **idx_payment_methods_user_id**: `CREATE INDEX idx_payment_methods_user_id ON payment_methods(user_id) WHERE is_active = TRUE`
  - Purpose: Fast retrieval of user's active payment methods
  - Justification: Primary query pattern for payment method selection, target <200ms for CRUD operations
- **idx_payment_methods_user_default**: `CREATE UNIQUE INDEX idx_payment_methods_user_default ON payment_methods(user_id) WHERE is_default = TRUE AND is_active = TRUE`
  - Purpose: Enforce one default payment method per user and fast default lookup
  - Justification: Unique partial index ensures business rule compliance and optimizes default payment method retrieval
- **idx_payment_methods_created_at**: `CREATE INDEX idx_payment_methods_created_at ON payment_methods(created_at DESC)`
  - Purpose: Chronological listing of payment methods
  - Justification: Used for displaying payment methods in order of addition

### Query Optimization

<!-- Identify potential performance bottlenecks and solutions -->

**Profile Loading** (Target: <1s):

- **Query Pattern**: `SELECT * FROM users WHERE id = $1`
- **Optimization**: Primary key lookup is already optimal, ensure connection pooling is configured
- **Expected Performance**: <50ms for single user profile retrieval

**Username Availability Check** (Target: <50ms):

- **Query Pattern**: `SELECT EXISTS(SELECT 1 FROM users WHERE LOWER(username) = LOWER($1))`
- **Optimization**: Use case-insensitive index `idx_users_username`, EXISTS clause for early termination
- **Expected Performance**: <50ms with index

**Payment Methods Retrieval** (Target: <200ms):

- **Query Pattern**: `SELECT * FROM payment_methods WHERE user_id = $1 AND is_active = TRUE ORDER BY is_default DESC, created_at DESC`
- **Optimization**: Use `idx_payment_methods_user_id` partial index, order by default first
- **Expected Performance**: <200ms for typical user with 1-5 payment methods

**Default Payment Method Lookup** (Target: <100ms):

- **Query Pattern**: `SELECT * FROM payment_methods WHERE user_id = $1 AND is_default = TRUE AND is_active = TRUE LIMIT 1`
- **Optimization**: Use `idx_payment_methods_user_default` unique partial index
- **Expected Performance**: <100ms with index

**Profile Update** (Target: <200ms):

- **Query Pattern**: `UPDATE users SET first_name = $1, last_name = $2, ... WHERE id = $3`
- **Optimization**: Primary key update is optimal, ensure updated_at trigger is efficient
- **Expected Performance**: <200ms including trigger execution

### Scalability Planning

<!-- Consider future growth and scaling needs -->

**Expected Data Volume**:

- **Users**: 100K users in first year, 1M users in 5 years
- **Payment Methods**: Average 2 payment methods per user = 200K in year 1, 2M in 5 years
- **Profile Images**: Stored in cloud storage (S3/GCS), only URLs in database
- **Growth Rate**: Estimated 20% annual user growth

**Partitioning Strategy**:

- **Not Required Initially**: Current volume projections don't warrant partitioning
- **Future Consideration**: If users table exceeds 10M rows, consider partitioning by:
  - Range partitioning on `created_at` (yearly partitions)
  - Or hash partitioning on `id` for even distribution
- **Payment Methods**: Consider partitioning by `user_id` hash if exceeds 20M rows

**Archiving Strategy**:

- **Inactive Users**: Users who haven't logged in for 3+ years
  - Archive to separate `users_archived` table
  - Maintain foreign key integrity for historical bookings
- **Inactive Payment Methods**: Payment methods marked `is_active = FALSE` for 2+ years
  - Archive to `payment_methods_archived` table
  - Keep for audit trail and compliance
- **Archival Process**: Quarterly batch job during low-traffic hours

**Caching Strategy**:

- **User Profiles**: Cache frequently accessed profiles in Redis (TTL: 1 hour)
- **Payment Methods**: Cache user's payment methods list (TTL: 30 minutes, invalidate on update)
- **Username Lookups**: Cache username existence checks (TTL: 5 minutes)
- **Cache Invalidation**: On profile update, payment method changes, or user deletion

## Migration Strategy

### Migration Steps

<!-- Define the steps needed to implement the schema changes -->

**Phase 1: Add New Columns to users Table (Non-Breaking)**

1. **Add nullable columns to users table**:

```sql
-- Migration: 001_add_profile_fields_to_users.sql
BEGIN;

-- Add new profile fields (all nullable initially for backward compatibility)
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS username VARCHAR(30) NULL,
  ADD COLUMN IF NOT EXISTS first_name VARCHAR(100) NULL,
  ADD COLUMN IF NOT EXISTS last_name VARCHAR(100) NULL,
  ADD COLUMN IF NOT EXISTS show_name_to_friends BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS profile_image_url TEXT NULL,
  ADD COLUMN IF NOT EXISTS gender VARCHAR(50) NULL,
  ADD COLUMN IF NOT EXISTS phone_number VARCHAR(20) NULL,
  ADD COLUMN IF NOT EXISTS birthday DATE NULL,
  ADD COLUMN IF NOT EXISTS street_address VARCHAR(255) NULL,
  ADD COLUMN IF NOT EXISTS city VARCHAR(100) NULL,
  ADD COLUMN IF NOT EXISTS postal_code VARCHAR(20) NULL,
  ADD COLUMN IF NOT EXISTS country VARCHAR(100) NULL;

COMMIT;
```

2. **Add constraints and indexes (after data population)**:

```sql
-- Migration: 002_add_profile_constraints_and_indexes.sql
BEGIN;

-- Add CHECK constraints
ALTER TABLE users
  ADD CONSTRAINT username_format CHECK (username IS NULL OR username ~ '^[a-zA-Z0-9_]{3,30}$'),
  ADD CONSTRAINT age_requirement CHECK (birthday IS NULL OR birthday <= CURRENT_DATE - INTERVAL '16 years'),
  ADD CONSTRAINT phone_format CHECK (phone_number IS NULL OR phone_number ~ '^\+?[0-9\s\-\(\)]+$');

-- Create indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users(LOWER(username)) WHERE username IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_users_birthday ON users(birthday) WHERE birthday IS NOT NULL;

-- Modify email index to be case-insensitive (if not already)
DROP INDEX IF EXISTS users_email_key;
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users(LOWER(email));

COMMIT;
```

3. **Make required fields NOT NULL (after all users have data)**:

```sql
-- Migration: 003_make_profile_fields_required.sql
-- Run this ONLY after ensuring all existing users have username, first_name, last_name populated
BEGIN;

-- Make username, first_name, last_name NOT NULL
ALTER TABLE users
  ALTER COLUMN username SET NOT NULL,
  ALTER COLUMN first_name SET NOT NULL,
  ALTER COLUMN last_name SET NOT NULL,
  ALTER COLUMN show_name_to_friends SET NOT NULL;

-- Add unique constraint on username
ALTER TABLE users ADD CONSTRAINT users_username_unique UNIQUE USING INDEX idx_users_username;

COMMIT;
```

**Phase 2: Create payment_methods Table** 4. **Create payment_methods table with all constraints**:

```sql
-- Migration: 004_create_payment_methods_table.sql
BEGIN;

-- Create payment_methods table
CREATE TABLE IF NOT EXISTS payment_methods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  payment_type VARCHAR(20) NOT NULL CHECK (payment_type IN ('credit_card', 'debit_card', 'paypal', 'bank_transfer')),
  payment_token TEXT NOT NULL,
  card_last_4 VARCHAR(4) NULL CHECK (card_last_4 IS NULL OR card_last_4 ~ '^[0-9]{4}$'),
  card_brand VARCHAR(20) NULL,
  expiry_month INTEGER NULL CHECK (expiry_month IS NULL OR expiry_month BETWEEN 1 AND 12),
  expiry_year INTEGER NULL CHECK (expiry_year IS NULL OR expiry_year >= EXTRACT(YEAR FROM CURRENT_DATE)),
  billing_street_address TEXT NULL,
  billing_city TEXT NULL,
  billing_postal_code TEXT NULL,
  billing_country TEXT NULL,
  is_default BOOLEAN NOT NULL DEFAULT FALSE,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_payment_methods_user_id ON payment_methods(user_id) WHERE is_active = TRUE;
CREATE UNIQUE INDEX idx_payment_methods_user_default ON payment_methods(user_id) WHERE is_default = TRUE AND is_active = TRUE;
CREATE INDEX idx_payment_methods_created_at ON payment_methods(created_at DESC);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_payment_methods_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER payment_methods_updated_at_trigger
  BEFORE UPDATE ON payment_methods
  FOR EACH ROW
  EXECUTE FUNCTION update_payment_methods_updated_at();

COMMIT;
```

**Phase 3: Enable Row-Level Security (RLS)** 5. **Enable RLS policies for data protection**:

```sql
-- Migration: 005_enable_rls_policies.sql
BEGIN;

-- Enable RLS on users table (if not already enabled)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own profile
CREATE POLICY users_select_own ON users
  FOR SELECT
  USING (auth.uid() = id);

-- Policy: Users can update their own profile
CREATE POLICY users_update_own ON users
  FOR UPDATE
  USING (auth.uid() = id);

-- Enable RLS on payment_methods table
ALTER TABLE payment_methods ENABLE ROW LEVEL SECURITY;

-- Policy: Users can read their own payment methods
CREATE POLICY payment_methods_select_own ON payment_methods
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own payment methods
CREATE POLICY payment_methods_insert_own ON payment_methods
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own payment methods
CREATE POLICY payment_methods_update_own ON payment_methods
  FOR UPDATE
  USING (auth.uid() = user_id);

-- Policy: Users can delete their own payment methods
CREATE POLICY payment_methods_delete_own ON payment_methods
  FOR DELETE
  USING (auth.uid() = user_id);

COMMIT;
```

### Rollback Plan

<!-- Define how to safely rollback changes if needed -->

**Rollback Phase 3 (RLS Policies)**:

```sql
-- Rollback: 005_enable_rls_policies.sql
BEGIN;

-- Drop RLS policies
DROP POLICY IF EXISTS users_select_own ON users;
DROP POLICY IF EXISTS users_update_own ON users;
DROP POLICY IF EXISTS payment_methods_select_own ON payment_methods;
DROP POLICY IF EXISTS payment_methods_insert_own ON payment_methods;
DROP POLICY IF EXISTS payment_methods_update_own ON payment_methods;
DROP POLICY IF EXISTS payment_methods_delete_own ON payment_methods;

-- Disable RLS (only if it wasn't enabled before)
-- ALTER TABLE users DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE payment_methods DISABLE ROW LEVEL SECURITY;

COMMIT;
```

**Rollback Phase 2 (payment_methods Table)**:

```sql
-- Rollback: 004_create_payment_methods_table.sql
BEGIN;

-- Drop trigger and function
DROP TRIGGER IF EXISTS payment_methods_updated_at_trigger ON payment_methods;
DROP FUNCTION IF EXISTS update_payment_methods_updated_at();

-- Drop table (CASCADE will drop all dependent objects)
DROP TABLE IF EXISTS payment_methods CASCADE;

COMMIT;
```

**Rollback Phase 1 (users Table Modifications)**:

```sql
-- Rollback: 003_make_profile_fields_required.sql
BEGIN;

ALTER TABLE users
  ALTER COLUMN username DROP NOT NULL,
  ALTER COLUMN first_name DROP NOT NULL,
  ALTER COLUMN last_name DROP NOT NULL,
  ALTER COLUMN show_name_to_friends DROP NOT NULL;

ALTER TABLE users DROP CONSTRAINT IF EXISTS users_username_unique;

COMMIT;

-- Rollback: 002_add_profile_constraints_and_indexes.sql
BEGIN;

DROP INDEX IF EXISTS idx_users_username;
DROP INDEX IF EXISTS idx_users_birthday;
DROP INDEX IF EXISTS idx_users_email;

ALTER TABLE users
  DROP CONSTRAINT IF EXISTS username_format,
  DROP CONSTRAINT IF EXISTS age_requirement,
  DROP CONSTRAINT IF EXISTS phone_format;

-- Recreate original email unique constraint if needed
CREATE UNIQUE INDEX IF NOT EXISTS users_email_key ON users(email);

COMMIT;

-- Rollback: 001_add_profile_fields_to_users.sql
BEGIN;

ALTER TABLE users
  DROP COLUMN IF EXISTS username,
  DROP COLUMN IF EXISTS first_name,
  DROP COLUMN IF EXISTS last_name,
  DROP COLUMN IF EXISTS show_name_to_friends,
  DROP COLUMN IF EXISTS profile_image_url,
  DROP COLUMN IF EXISTS gender,
  DROP COLUMN IF EXISTS phone_number,
  DROP COLUMN IF EXISTS birthday;

COMMIT;
```

### Data Migration

<!-- If existing data needs to be migrated -->

**Data Transformation**:

- **Existing Users**: Need to populate new required fields (username, first_name, last_name)
  - Strategy 1: Prompt existing users to complete profile on next login
  - Strategy 2: Generate temporary usernames from email (e.g., `user_12345`) and derive names from `display_name`
  - Strategy 3: Use `display_name` as temporary first_name, set last_name to empty string initially
- **Recommended Approach**:
  ```sql
  -- Data migration script to populate required fields for existing users
  UPDATE users
  SET
    username = LOWER(CONCAT('user_', SUBSTRING(id::text, 1, 8))),
    first_name = COALESCE(display_name, 'User'),
    last_name = COALESCE(SPLIT_PART(display_name, ' ', 2), ''),
    show_name_to_friends = FALSE
  WHERE username IS NULL;
  ```

**Data Validation**:

- **Pre-Migration Checks**:
  - Verify all users have valid email addresses
  - Check for duplicate emails (should not exist due to existing constraint)
  - Identify users without `display_name` for special handling
- **Post-Migration Validation**:

  ```sql
  -- Verify all users have required fields
  SELECT COUNT(*) FROM users WHERE username IS NULL OR first_name IS NULL OR last_name IS NULL;
  -- Expected: 0

  -- Verify username uniqueness
  SELECT username, COUNT(*) FROM users GROUP BY username HAVING COUNT(*) > 1;
  -- Expected: 0 rows

  -- Verify age constraint
  SELECT COUNT(*) FROM users WHERE birthday IS NOT NULL AND birthday > CURRENT_DATE - INTERVAL '16 years';
  -- Expected: 0

  -- Verify payment methods foreign keys
  SELECT COUNT(*) FROM payment_methods pm LEFT JOIN users u ON pm.user_id = u.id WHERE u.id IS NULL;
  -- Expected: 0
  ```

**Backup Strategy**:

- **Full Database Backup**: Before starting migration
  ```bash
  pg_dump -h localhost -U postgres -d breakout_buddies -F c -f backup_before_profile_migration_$(date +%Y%m%d_%H%M%S).dump
  ```
- **Table-Specific Backup**: Backup users table before modifications
  ```sql
  CREATE TABLE users_backup_20251012 AS SELECT * FROM users;
  ```
- **Verification**: Test restore process on staging environment before production migration
- **Rollback Window**: Keep backups for at least 30 days after migration

## Integration Impact

> **ðŸ“‹ Primary Documentation**: API Design Task (PF-TSK-020) and TDD Creation Task (PF-TSK-022)
> **ðŸ”— Link**: [API Design - Basic Profile Data (PD-API-011)](../../api/specifications/specifications/api-1.2.1-basic-profile-data.md) | [TDD-1.2.1 - Basic Profile Data](../../../technical/architecture/design-docs/tdd/tdd/tdd-1.2.1-basic-profile-data-t1.md) > **ðŸ‘¤ Owner**: API Design Task and TDD Creation Task
>
> **Purpose**: This section provides database-level integration notes. Detailed API specifications and service implementation details are documented in the API Design and TDD documents.

### Database-Level Integration Notes

**Schema Access Requirements**:

- **users table**: Extended with profile fields requiring read/write access from authentication service
- **payment_methods table**: New table requiring read/write access from payment service
- **RLS Policies**: Enforce user-level access control at database level (users can only access their own data)

**Cross-Schema Dependencies**:

- Foreign key from `payment_methods.user_id` to `users.id` with CASCADE delete
- Username uniqueness enforced at database level via unique index on `LOWER(username)`
- Email uniqueness enforced at database level via unique index on `LOWER(email)`
- Age validation (16+) enforced via CHECK constraint on `birthday` field

**Database-Level Validation**:

- Username format: 3-30 characters, alphanumeric + underscores (CHECK constraint)
- Phone number format: International format support (CHECK constraint)
- Card expiry validation: Must not be in the past (CHECK constraint)
- One default payment method per user: Enforced via unique partial index

**Encryption Requirements**:

- `payment_token` field: AES-256 encryption at rest (application-level)
- Billing address fields: AES-256 encryption at rest (application-level)
- Database stores encrypted values; decryption handled by application layer

**Performance Considerations**:

- Case-insensitive indexes on username and email for fast lookups (<50ms target)
- Partial indexes on `payment_methods` for active records only
- Unique partial index for default payment method enforcement and fast retrieval

## Security Considerations

### Data Privacy

<!-- Address data privacy and protection requirements -->

**Sensitive Data Protection**:

- **Payment Tokens**:

  - Encrypted at rest using AES-256 encryption
  - Never store full card numbers (PCI DSS Level 1 compliance)
  - Tokenization via payment gateway before storage
  - Encryption keys stored in secure key management service (AWS KMS/Google Cloud KMS)

- **Billing Addresses**:

  - Encrypted at rest using AES-256 encryption
  - Stored as encrypted JSON in `billing_address` field
  - Decrypted only when needed for payment processing

- **Personal Information**:

  - Names, birthday, phone numbers are sensitive personal data
  - Protected by Row-Level Security (RLS) policies
  - Access logged for audit trail
  - GDPR/FADP compliance for data subject rights

- **Profile Pictures**:
  - Stored in private cloud storage buckets
  - Access via signed URLs with expiration
  - No direct public access to storage

**Access Controls**:

- **User Access**:

  - Users can only read/update their own profile (enforced by RLS)
  - Users can only manage their own payment methods (enforced by RLS)
  - Username and profile picture are publicly visible
  - Real names visible only if `show_name_to_friends = TRUE`

- **Admin Access**:

  - Admins can view user profiles for support purposes (logged)
  - Admins cannot view payment tokens (encrypted, keys not accessible)
  - Admin actions logged for audit trail

- **Service Access**:
  - Payment service has access to encrypted payment tokens
  - Analytics service receives anonymized data only
  - Notification service has read-only access to email and names

**Encryption**:

- **At Rest**:

  - Payment tokens: AES-256 encryption
  - Billing addresses: AES-256 encryption
  - Database: Full disk encryption at infrastructure level
  - Backups: Encrypted using same keys as production data

- **In Transit**:

  - All API communication over HTTPS/TLS 1.3
  - Database connections over SSL/TLS
  - Payment gateway communication over HTTPS with certificate pinning

- **Key Management**:
  - Encryption keys stored in AWS KMS or Google Cloud KMS
  - Key rotation every 90 days
  - Separate keys for production and non-production environments
  - Keys never stored in application code or version control

### Compliance Requirements

<!-- Address regulatory and compliance needs -->

**PCI DSS (Payment Card Industry Data Security Standard)**:

- **Level 1 Compliance**: Required for storing payment information
- **Requirements Met**:
  - Never store full card numbers (only last 4 digits)
  - Never store CVV/CVC codes
  - Tokenization via PCI-compliant payment gateway
  - Encryption of payment tokens at rest (AES-256)
  - Secure transmission of card data (HTTPS/TLS 1.3)
  - Access controls and audit logging
  - Regular security assessments and penetration testing
- **Tokenization Workflow**: Card data sent directly to payment gateway, only token stored in database

**GDPR (General Data Protection Regulation)**:

- **Data Subject Rights**:
  - Right to access: Users can export their profile data
  - Right to rectification: Users can update their profile
  - Right to erasure: Users can delete their account (cascade delete payment methods)
  - Right to data portability: Export profile in JSON format
  - Right to object: Users can opt-out of data processing for marketing
- **Age Verification**: Minimum age 16 years (enforced via CHECK constraint)
- **Consent Management**: Explicit consent for data processing during registration
- **Data Minimization**: Only collect necessary data for service provision
- **Privacy by Design**: Default privacy settings (names hidden by default)

**FADP (Swiss Federal Act on Data Protection)**:

- **Similar to GDPR**: Switzerland-specific data protection requirements
- **Age Verification**: Minimum age 16 years (same as GDPR)
- **Data Localization**: Consider storing Swiss users' data in Swiss data centers
- **Cross-Border Transfers**: Ensure adequate protection for data transfers outside Switzerland

**Data Retention**:

- **Active Users**: Data retained as long as account is active
- **Inactive Users**: Data retained for 3 years after last login, then archived
- **Deleted Accounts**:
  - Soft delete for 30 days (recovery period)
  - Hard delete after 30 days (except data required for legal/compliance purposes)
  - Payment transaction history retained for 7 years (legal requirement)

**Audit Logging**:

- **Logged Events**:
  - Profile creation and updates
  - Payment method additions, updates, deletions
  - Access to sensitive data by admins
  - Failed authentication attempts
  - Data exports and deletions
- **Log Retention**: 1 year for operational logs, 7 years for compliance logs
- **Log Security**: Logs stored in tamper-proof, append-only storage

## Testing Strategy

> **ðŸ“‹ Primary Documentation**: Test Specification Creation Task (PF-TSK-012)
> **ðŸ”— Link**: [Test Specification - Basic Profile Data (PD-TST-011)](../../testing/test-specifications/test-spec-1.2.1-basic-profile-data.md) > **ðŸ‘¤ Owner**: Test Specification Creation Task
>
> **Purpose**: This section provides database-specific testing considerations. Comprehensive test plans, test cases, and integration testing strategies are documented in the Test Specification document.

### Database-Specific Testing Considerations

**Schema Constraint Testing**:

- **Migration Rollback Testing**: All migration scripts must be tested for successful rollback before production deployment
- **Constraint Validation**: Verify all CHECK constraints (username format, age requirement, phone format, card expiry) reject invalid data
- **Unique Constraint Testing**: Verify case-insensitive uniqueness for username and email fields
- **Foreign Key Cascade Testing**: Verify payment methods are deleted when user is deleted (CASCADE behavior)

**RLS Policy Testing**:

- **Access Control Verification**: Test RLS policies with multiple user roles to ensure users can only access their own data
- **Policy Coverage**: Verify all CRUD operations (SELECT, INSERT, UPDATE, DELETE) are covered by appropriate policies
- **Security Testing**: Attempt unauthorized access to verify policies block cross-user data access

**Performance Testing**:

- **Index Effectiveness**: Verify indexes provide expected query performance (<50ms for username/email lookups, <200ms for payment methods)
- **Migration Performance**: Test migration scripts with production-scale data volumes (1M+ users)
- **Concurrent Access**: Test database behavior under concurrent write operations (multiple users updating profiles simultaneously)

**Data Integrity Testing**:

- **Partial Index Validation**: Verify unique partial index enforces one default payment method per user
- **Encryption Verification**: Confirm payment tokens and billing addresses are encrypted at rest
- **Data Migration Validation**: Verify existing user data is correctly migrated to new schema structure

**Rollback Testing**:

- **Rollback Script Validation**: Test all rollback scripts restore database to previous state without data loss
- **Backup and Restore**: Verify backup and restore procedures work correctly before production migration

## Documentation Updates Required

### Technical Documentation

<!-- List documentation that needs updates -->

- **Database Reference Document** (`database-reference.md`):

  - Add new fields to `users` table documentation
  - Add `payment_methods` table documentation
  - Update ERD diagram to include new relationships
  - Document new indexes and constraints

- **API Documentation** (`api-reference.md`):

  - Document new profile management endpoints
  - Document new payment methods endpoints
  - Update authentication endpoints documentation
  - Add request/response examples

- **Security Documentation** (`security-guidelines.md`):

  - Document encryption strategy for payment data
  - Document RLS policies implementation
  - Add PCI DSS compliance guidelines
  - Document key management procedures

- **Migration Guide** (`migration-guide.md`):

  - Document migration steps for existing deployments
  - Provide rollback procedures
  - Include data migration scripts
  - Add troubleshooting section

- **Architecture Decision Records** (ADRs):
  - ADR: Choice of tokenization over direct card storage
  - ADR: Username immutability decision
  - ADR: Privacy-by-default approach (names hidden)
  - ADR: Soft delete for payment methods

### User Documentation

<!-- List user-facing documentation that needs updates -->

- **User Guide** (`user-guide.md`):

  - Add section on profile management
  - Add section on payment methods management
  - Explain username selection and restrictions
  - Document privacy controls for name visibility

- **FAQ** (`faq.md`):

  - Can I change my username? (No, immutable)
  - How is my payment information secured? (Tokenization, encryption)
  - Who can see my real name? (Only if you enable visibility)
  - What payment methods are supported? (Credit/debit cards, PayPal, bank transfer)

- **Privacy Policy** (`privacy-policy.md`):

  - Update data collection section (new profile fields)
  - Add payment data handling section
  - Document data retention policies
  - Explain user rights (GDPR/FADP)

- **Terms of Service** (`terms-of-service.md`):

  - Add section on payment methods usage
  - Document username ownership and restrictions
  - Add age requirement (16+ years)

- **Help Center Articles**:
  - "How to set up your profile"
  - "How to add a payment method"
  - "How to manage your privacy settings"
  - "Understanding username requirements"
  - "How to change your default payment method"

## Related Resources

- [Database Schema Design Task](/doc/process-framework/tasks/02-design/database-schema-design-task.md)
- [API Design Task](/doc/process-framework/tasks/02-design/api-design-task.md)
- [System Architecture Review](/doc/process-framework/tasks/01-planning/system-architecture-review.md)
